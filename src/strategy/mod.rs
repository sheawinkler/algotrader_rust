//! Trading strategies for the algorithmic trading system.

mod mean_reversion;
mod momentum;

use async_trait::async_trait;
use std::collections::HashMap;
use crate::utils::types::{MarketData as UnifiedMarketData};

pub use mean_reversion::MeanReversionStrategy;
pub use momentum::MomentumStrategy;

/// Trait defining the common interface for all trading strategies
#[async_trait]
pub trait TradingStrategy: Send + Sync {
    /// Get the name of the strategy
    fn name(&self) -> &'static str;
    
    /// Initialize the strategy with the given parameters
    async fn initialize(&mut self, params: HashMap<String, String>) -> crate::Result<()>;
    
    /// Analyze the market and generate trading signals
    async fn analyze(&self, market_data: &crate::utils::types::MarketData) -> crate::Result<Vec<TradeSignal>>;
    
    /// Get the current parameters of the strategy
    fn get_parameters(&self) -> HashMap<String, String>;
}


/// Trade side (buy or sell)
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TradeSide {
    Buy,
    Sell,
}

/// Trading signal generated by a strategy
#[derive(Debug, Clone)]
pub struct TradeSignal {
    /// The strategy that generated this signal
    pub strategy_name: String,
    /// The trading pair
    pub symbol: String,
    /// The recommended action
    pub action: Action,
    /// The suggested quantity (in base currency)
    pub quantity: f64,
    /// The suggested price (optional, use None for market orders)
    pub price: Option<f64>,
    /// The reason for the signal
    pub reason: String,
    /// The confidence level of the signal (0.0 to 1.0)
    pub confidence: f64,
}

/// Recommended trading action
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Action {
    Buy,
    Sell,
    Hold,
    ClosePosition,
}

/// Factory for creating trading strategies
pub struct StrategyFactory;

impl StrategyFactory {
    /// Create a new strategy by name
    pub fn create_strategy(name: &str) -> crate::Result<Box<dyn TradingStrategy>> {
        match name.to_lowercase().as_str() {
            "mean_reversion" => Ok(Box::new(MeanReversionStrategy::new())),
            "momentum" => Ok(Box::new(MomentumStrategy::new())),
            _ => Err(crate::Error::StrategyError(format!("Unknown strategy: {}", name))),
        }
    }
    
    /// Create multiple strategies at once
    pub fn create_strategies(names: &[&str]) -> crate::Result<HashMap<String, Box<dyn TradingStrategy>>> {
        let mut strategies = HashMap::new();
        
        for name in names {
            let strategy = Self::create_strategy(name)?;
            strategies.insert(name.to_string(), strategy);
        }
        
        Ok(strategies)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_strategy_factory() {
        let strategy = StrategyFactory::create_strategy("mean_reversion");
        assert!(strategy.is_ok());
        assert_eq!(strategy.unwrap().name(), "Mean Reversion");
        
        let strategy = StrategyFactory::create_strategy("momentum");
        assert!(strategy.is_ok());
        assert_eq!(strategy.unwrap().name(), "Momentum");
        
        let strategy = StrategyFactory::create_strategy("unknown");
        assert!(matches!(strategy, Err(crate::Error::StrategyError(_))));
    }
    
    #[test]
    fn test_create_multiple_strategies() {
        let strategies = StrategyFactory::create_strategies(&["mean_reversion", "momentum"]);
        assert!(strategies.is_ok());
        let strategies = strategies.unwrap();
        assert_eq!(strategies.len(), 2);
        assert!(strategies.contains_key("mean_reversion"));
        assert!(strategies.contains_key("momentum"));
    }
}
