use serde::Serialize;
use std::collections::{HashMap, VecDeque};
use std::time::Duration;

use super::metrics::StrategyMetrics;
use crate::analysis::performance_metrics::TradeRecord;

/// Strategy optimization suggestion
#[derive(Debug, Clone, Serialize)]
pub struct OptimizationSuggestion {
    pub strategy_name: String,
    pub parameter: String,
    pub current_value: f64,
    pub suggested_value: f64,
    pub confidence: f64,
    pub reason: String,
}

/// Analyzes strategy performance and suggests optimizations
#[derive(Debug, Clone)]
pub struct StrategyAnalyzer {
    /// Minimum number of trades before making suggestions
    min_trades: u32,
    /// Minimum win rate to consider strategy viable
    min_win_rate: f64,
    /// Maximum acceptable drawdown
    max_drawdown_pct: f64,
    /// Lookback period for performance analysis
    lookback_period: Duration,
    /// Recent trade history
    trade_history: VecDeque<TradeRecord>,
    /// Maximum number of trades to keep in history
    max_history_size: usize,
    /// Last signal generated by the strategy
    last_signal: Option<String>,
}

impl Default for StrategyAnalyzer {
    fn default() -> Self {
        Self {
            min_trades: 20,
            min_win_rate: 0.4,                                      // 40%
            max_drawdown_pct: 20.0,                                 // 20%
            lookback_period: Duration::from_secs(7 * 24 * 60 * 60), // 1 week
            trade_history: VecDeque::with_capacity(1000),
            max_history_size: 1000,
            last_signal: None,
        }
    }
}

impl StrategyAnalyzer {
    /// Create a new strategy analyzer with custom parameters
    pub fn new(
        min_trades: u32, min_win_rate: f64, max_drawdown_pct: f64, lookback_days: u32,
    ) -> Self {
        Self {
            min_trades,
            min_win_rate: min_win_rate / 100.0, // Convert from percentage
            max_drawdown_pct,
            lookback_period: Duration::from_secs(lookback_days as u64 * 24 * 60 * 60),
            trade_history: VecDeque::with_capacity(1000),
            max_history_size: 1000,
            last_signal: None,
        }
    }

    /// Analyze a single trade and update internal state
    pub fn analyze_trade(&mut self, trade: &TradeRecord) {
        // Store the trade in history
        if self.trade_history.len() >= self.max_history_size {
            self.trade_history.pop_front();
        }
        self.trade_history.push_back(trade.clone());

        // Update last signal based on the trade
        self.last_signal = Some(if trade.pnl.unwrap_or(0.0) >= 0.0 {
            "win".to_string()
        } else {
            "loss".to_string()
        });
    }

    /// Get the last signal generated by the strategy
    pub fn last_signal(&self) -> Option<String> {
        self.last_signal.clone()
    }

    /// Get insights about the strategy's performance
    pub fn get_insights(&self) -> Option<HashMap<String, String>> {
        if self.trade_history.is_empty() {
            return None;
        }

        let mut insights = HashMap::new();
        insights.insert("total_trades".to_string(), self.trade_history.len().to_string());
        insights.insert(
            "last_signal".to_string(),
            self.last_signal
                .clone()
                .unwrap_or_else(|| "none".to_string()),
        );

        // Calculate win rate
        let wins = self
            .trade_history
            .iter()
            .filter(|t| t.pnl.unwrap_or(0.0) >= 0.0)
            .count();
        let win_rate = if !self.trade_history.is_empty() {
            wins as f64 / self.trade_history.len() as f64
        } else {
            0.0
        };

        insights.insert("win_rate".to_string(), format!("{:.1}%", win_rate * 100.0));

        // Calculate total PnL
        let total_pnl: f64 = self.trade_history.iter().filter_map(|t| t.pnl).sum();

        insights.insert("total_pnl".to_string(), format!("${:.2}", total_pnl));

        Some(insights)
    }

    /// Analyze strategy performance and generate optimization suggestions
    pub fn analyze_strategy(
        &self, metrics: &StrategyMetrics, current_params: &HashMap<String, f64>,
    ) -> Vec<OptimizationSuggestion> {
        let mut suggestions = Vec::new();

        // Skip analysis if not enough data
        if metrics.total_trades < self.min_trades {
            return suggestions;
        }

        // Check if strategy is underperforming
        if metrics.win_rate < self.min_win_rate {
            suggestions.push(self.suggest_win_rate_improvement(metrics, current_params));
        }

        // Check for excessive drawdown
        if metrics.current_drawdown > metrics.total_pnl.abs() * (self.max_drawdown_pct / 100.0) {
            suggestions.push(self.suggest_drawdown_reduction(metrics, current_params));
        }

        // Check for parameter optimization opportunities
        suggestions.extend(self.suggest_parameter_optimizations(metrics, current_params));

        suggestions
    }

    /// Generate suggestions to improve win rate
    fn suggest_win_rate_improvement(
        &self, metrics: &StrategyMetrics, current_params: &HashMap<String, f64>,
    ) -> OptimizationSuggestion {
        // Simple example: suggest increasing confirmation periods for trend-following strategies
        let mut suggestion = OptimizationSuggestion {
            strategy_name: metrics.strategy_name.clone(),
            parameter: "confirmation_period".to_string(),
            current_value: current_params
                .get("confirmation_period")
                .copied()
                .unwrap_or(1.0),
            suggested_value: 0.0,
            confidence: 0.7,
            reason: format!(
                "Win rate ({:.1}%) is below minimum threshold ({:.1}%)",
                metrics.win_rate * 100.0,
                self.min_win_rate * 100.0
            ),
        };

        // Adjust suggested value based on strategy type
        if metrics.strategy_name.contains("Trend") {
            suggestion.suggested_value = suggestion.current_value * 1.5;
            suggestion.parameter = "trend_confirmation_period".to_string();
        } else if metrics.strategy_name.contains("MeanReversion") {
            suggestion.suggested_value = suggestion.current_value * 0.8;
            suggestion.parameter = "oversold_threshold".to_string();
        }

        suggestion
    }

    /// Generate suggestions to reduce drawdown
    fn suggest_drawdown_reduction(
        &self, metrics: &StrategyMetrics, current_params: &HashMap<String, f64>,
    ) -> OptimizationSuggestion {
        let current_stop_loss = current_params.get("stop_loss_pct").copied().unwrap_or(5.0);
        let suggested_stop = current_stop_loss * 0.8; // Tighten stop loss by 20%

        OptimizationSuggestion {
            strategy_name: metrics.strategy_name.clone(),
            parameter: "stop_loss_pct".to_string(),
            current_value: current_stop_loss,
            suggested_value: suggested_stop,
            confidence: 0.8,
            reason: format!(
                "Current drawdown ({:.1}%) exceeds maximum threshold ({:.1}%)",
                metrics.current_drawdown / metrics.total_pnl.abs() * 100.0,
                self.max_drawdown_pct
            ),
        }
    }

    /// Generate parameter optimization suggestions
    fn suggest_parameter_optimizations(
        &self, metrics: &StrategyMetrics, current_params: &HashMap<String, f64>,
    ) -> Vec<OptimizationSuggestion> {
        let mut suggestions = Vec::new();

        // Example: Adjust position size based on win rate and profit factor
        if metrics.total_trades >= 30 {
            let current_pos_size = current_params.get("position_size").copied().unwrap_or(0.1);
            let kelly = metrics.kelly_criterion();

            // Only suggest if current position size is significantly different from Kelly
            if (current_pos_size - kelly).abs() > 0.05 {
                suggestions.push(OptimizationSuggestion {
                    strategy_name: metrics.strategy_name.clone(),
                    parameter: "position_size".to_string(),
                    current_value: current_pos_size,
                    suggested_value: kelly,
                    confidence: 0.6,
                    reason: format!(
                        "Kelly Criterion suggests optimal position size of {:.1}%",
                        kelly * 100.0
                    ),
                });
            }
        }

        // Add more parameter optimization logic here

        suggestions
    }

    /// Generate a performance report with optimization suggestions
    pub fn generate_report(
        &self, metrics: &StrategyMetrics, current_params: &HashMap<String, f64>,
    ) -> String {
        let mut report = format!(
            "Strategy Performance Report\n,\
             ==========================\n,\
             Strategy: {}\n,\
             Total Trades: {}\n,\
             Win Rate: {:.1}%\n,\
             Total PnL: {:.2} USDC\n,\
             Max Drawdown: {:.1}%\n,\
             Profit Factor: {:.2}\n,\
             Kelly Criterion: {:.1}%\n,\
             Risk of Ruin: {:.1}%\n\n,\
             Current Parameters:\n",
            metrics.strategy_name,
            metrics.total_trades,
            metrics.win_rate * 100.0,
            metrics.total_pnl,
            metrics.max_drawdown,
            metrics.profit_factor,
            metrics.kelly_criterion() * 100.0,
            metrics.risk_of_ruin() * 100.0,
        );

        // Add current parameters
        for (param, &value) in current_params {
            report.push_str(&format!("  {}: {:.4}\n", param, value));
        }

        // Add optimization suggestions
        let suggestions = self.analyze_strategy(metrics, current_params);
        if !suggestions.is_empty() {
            report.push_str("\nOptimization Suggestions:\n");
            for (i, suggestion) in suggestions.iter().enumerate() {
                report.push_str(&format!(
                    "{}. {}: {:.4} -> {:.4} (Confidence: {:.0}%)\n\
                     Reason: {}\n",
                    i + 1,
                    suggestion.parameter,
                    suggestion.current_value,
                    suggestion.suggested_value,
                    suggestion.confidence * 100.0,
                    suggestion.reason
                ));
            }
        } else {
            report.push_str("\nNo optimization suggestions at this time.\n");
        }

        report
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_analyzer_suggestions() {
        let analyzer = StrategyAnalyzer::default();
        let mut metrics = StrategyMetrics::new("TestStrategy");

        // Simulate some trades
        for _ in 0..10 {
            metrics.record_trade(100.0); // Winning trades
        }
        for _ in 0..15 {
            metrics.record_trade(-50.0); // Losing trades
        }

        let mut params = HashMap::new();
        params.insert("position_size".to_string(), 0.1);
        params.insert("stop_loss_pct".to_string(), 5.0);

        let suggestions = analyzer.analyze_strategy(&metrics, &params);
        assert!(!suggestions.is_empty());

        // Ensure we received at least one optimization suggestion
        assert!(!suggestions.is_empty());

        // Generate report
        let report = analyzer.generate_report(&metrics, &params);
        assert!(report.contains("Strategy Performance Report"));
        assert!(report.contains("Optimization Suggestions"));
    }
}
