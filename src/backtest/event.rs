use std::collections::VecDeque;

use super::SimulatedTrade;
use crate::utils::types::MarketData;

/// Events that drive the back-testing simulation.
#[derive(Debug, Clone)]
pub enum BacktestEvent {
    /// Incoming market data (tick or aggregated candle)
    Market(MarketData),
    /// A trade that has been generated by a strategy and is ready to be applied to the portfolio
    Trade(SimulatedTrade),
}

/// Simple FIFO event queue for the simulator loop.
#[derive(Default)]
pub struct EventQueue {
    queue: VecDeque<BacktestEvent>,
}

impl EventQueue {
    /// Create an empty queue
    pub fn new() -> Self { Self { queue: VecDeque::new() } }

    /// Push a new event to the back of the queue
    pub fn push(&mut self, evt: BacktestEvent) { self.queue.push_back(evt); }

    /// Pop the next event, if any
    pub fn pop(&mut self) -> Option<BacktestEvent> { self.queue.pop_front() }

    /// Whether queue is empty
    pub fn is_empty(&self) -> bool { self.queue.is_empty() }
}

